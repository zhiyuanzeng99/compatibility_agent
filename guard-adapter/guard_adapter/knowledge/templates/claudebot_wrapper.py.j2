{# ClaudeBot å®‰å…¨åŒ…è£…å™¨æ¨¡æ¿ #}
"""
å®‰å…¨å¢å¼ºçš„ ClaudeBot åŒ…è£…å™¨
ç”± GuardAdapter è‡ªåŠ¨ç”Ÿæˆäº {{ timestamp }}
ç›®æ ‡é¡¹ç›®: {{ project_path }}
"""

from typing import Any, Optional
{% if has_async %}
import asyncio
{% endif %}

from guard_wrapper import guard, CheckResult


class Safe{{ class_name }}:
    """
    å®‰å…¨å¢å¼ºçš„ {{ class_name }} åŒ…è£…å™¨

    åŠŸèƒ½:
    1. è¾“å…¥æ ¡éªŒ - é˜²æ­¢ Prompt Injection
    2. å·¥å…·è°ƒç”¨æ£€æŸ¥ - æ‹¦æˆªå±é™©æ“ä½œ
    3. è¾“å‡ºæ ¡éªŒ - æ•æ„Ÿä¿¡æ¯è„±æ•
    """

    def __init__(self, original_bot: Any):
        self.bot = original_bot
        self.guard = guard
        self._interception_log = []

{% if has_async %}
    async def {{ main_method }}(self, user_input: str) -> str:
        """å®‰å…¨å¢å¼ºçš„ä¸»æ–¹æ³• (å¼‚æ­¥)"""
        # Step 1: è¾“å…¥æ ¡éªŒ
        input_check = self.guard.check_input(user_input)
        if not input_check.is_safe:
            self._log_interception('input', user_input, input_check)
            return f"ğŸš« è¾“å…¥è¢«æ‹¦æˆª: {input_check.reason}"

        # Step 2: è°ƒç”¨åŸæœ‰é€»è¾‘
        try:
            response = await self.bot.{{ main_method }}(user_input)
        except Exception as e:
            return f"âŒ å¤„ç†é”™è¯¯: {str(e)}"

        # Step 3: è¾“å‡ºæ ¡éªŒ
        output_check = self.guard.check_output(response)
        if output_check.sanitized_content:
            self._log_interception('output', response, output_check)
            response = output_check.sanitized_content

        return response
{% else %}
    def {{ main_method }}(self, user_input: str) -> str:
        """å®‰å…¨å¢å¼ºçš„ä¸»æ–¹æ³• (åŒæ­¥)"""
        # Step 1: è¾“å…¥æ ¡éªŒ
        input_check = self.guard.check_input(user_input)
        if not input_check.is_safe:
            self._log_interception('input', user_input, input_check)
            return f"ğŸš« è¾“å…¥è¢«æ‹¦æˆª: {input_check.reason}"

        # Step 2: è°ƒç”¨åŸæœ‰é€»è¾‘
        try:
            response = self.bot.{{ main_method }}(user_input)
        except Exception as e:
            return f"âŒ å¤„ç†é”™è¯¯: {str(e)}"

        # Step 3: è¾“å‡ºæ ¡éªŒ
        output_check = self.guard.check_output(response)
        if output_check.sanitized_content:
            self._log_interception('output', response, output_check)
            response = output_check.sanitized_content

        return response
{% endif %}

    def safe_tool_call(self, tool_name: str, tool_args: dict) -> tuple[bool, str]:
        """å®‰å…¨çš„å·¥å…·è°ƒç”¨æ£€æŸ¥"""
        check = self.guard.check_tool_call(tool_name, tool_args)
        if not check.is_safe:
            self._log_interception('tool', f"{tool_name}({tool_args})", check)
        return check.is_safe, check.reason

    def _log_interception(self, check_type: str, content: str, result):
        """è®°å½•æ‹¦æˆªæ—¥å¿—"""
        self._interception_log.append({
            'type': check_type,
            'content': content[:100],
            'reason': result.reason,
            'risk_level': result.risk_level,
        })

    def get_interception_log(self) -> list:
        """è·å–æ‹¦æˆªæ—¥å¿—"""
        return self._interception_log.copy()


def wrap_{{ class_name|lower }}(bot: Any) -> Safe{{ class_name }}:
    """ä¾¿æ·å‡½æ•°ï¼šåŒ…è£… {{ class_name }} å®ä¾‹"""
    return Safe{{ class_name }}(bot)
